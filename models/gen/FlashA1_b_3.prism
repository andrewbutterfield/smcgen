// Abs1 under development
dtmc

// Fixed Parameters are [("b",3)]

// Constant Decls:
// -----
const int b = 3;
const int p;
const int c;
const int w;
const int MAXDIFF;
const int INIT = 1;
const int WRITE = 2;
const int SELECT = 3;
const int FINISH = 4;

// Module Decls:
// -----

module Flash

// Variable Decls:
// -----
fm_clean_1: [0..p];
fm_clean_2: [0..p];
fm_clean_3: [0..p];
fm_erase_1: [0..w];
fm_erase_2: [0..w];
fm_erase_3: [0..w];
pc: [INIT..FINISH] init INIT;
i: [0..c] init 0;

// Commands:
// -----

[] pc = INIT -> 
  for  x:[1..b] apply &
  over true -> fm_clean'[x] = p & fm_erase[x] = 0 & pc' = WRITE

[] pc = WRITE & writeable != 0 -> 
  for  x:[1..b] apply +
  over true -> ((fm_clean[x] > 0 ? 1 / writeable : 0)): fm_clean'[x] = fm_clean[x] & i' = i + 1

[] pc = WRITE & writeable = 0 -> pc' = FINISH

[] pc = WRITE & i = c -> pc' = SELECT

[] pc = SELECT & (candidates = 0 | !(can_erase)) -> pc' = FINISH

[] pc = SELECT & candidates != 0 & can_erase -> 
  for  from:[1..b],to:[1..b] apply +
  over from != to -> ((cand(from,to) ? 1 / candidates : 0)): fm_clean'[to] = fm_clean[to] - dirty(from) & fm_clean'[from] = p & fm_erase'[from] = fm_erase[from] + 1 & i' = 0 & pc' = WRITE

[] pc = FINISH -> true

endmodule


// Formulae:
// -----

formula writeable = (fm_clean[1] != 0 ? 1 : 0) + (fm_clean[2] != 0 ? 1 : 0) + (fm_clean[3] != 0 ? 1 : 0)

formula dirty(x:[1..b]) = p - fm_clean[x]

formula cand(x:[1..b],y:[1..b]) = x != y & dirty(x) > 0 & fm_clean[x] >= dirty(x)

formula candidates = (cand(1,2) ? 1 : 0) + (cand(1,3) ? 1 : 0) + (cand(2,1) ? 1 : 0) + (cand(2,3) ? 1 : 0) + (cand(3,1) ? 1 : 0) + (cand(3,2) ? 1 : 0)

formula can_erase = fm_erase[1] < w & fm_erase[2] < w & fm_erase[3] < w

formula diff(x:[1..b],y:[1..b]) = fm_erase[x] - fm_erase[y]

formula toobig = diff(1,2) >= MAXDIFF | diff(1,3) >= MAXDIFF | diff(2,1) >= MAXDIFF | diff(2,3) >= MAXDIFF | diff(3,1) >= MAXDIFF | diff(3,2) >= MAXDIFF
